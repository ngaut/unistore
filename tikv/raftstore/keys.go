// Copyright 2019-present PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// See the License for the specific language governing permissions and
// limitations under the License.

package raftstore

import (
	"bytes"
	"encoding/binary"
	"fmt"

	"github.com/pingcap/badger/y"
	"github.com/pingcap/errors"
	"github.com/pingcap/kvproto/pkg/metapb"
	"github.com/pingcap/tidb/util/codec"
)

const (
	LocalPrefix byte = 0x01

	// We save two types region data in DB, for raft and other meta data.
	// When the store starts, we should iterate all region meta data to
	// construct peer, no need to travel large raft data, so we separate them
	// with different prefixes.
	RegionMetaPrefix byte = 0x03
	RaftStatePrefix  byte = 0x04
	RaftLogPrefix    byte = 0x05
	RaftLogLen            = 18     // prefix(2) + region_id(8) + index(8)
	regionMetaKeyLen      = 2 + 16 // prefix(2) + region_id(8) + version(4) + confVersion(4)
)

var (
	MinKey = []byte{0}

	// Data key has two prefix, meta 'm' and table 't',
	// extra keys has prefix 'm' + 1 = 'n',
	// extra table keys has prefix 't' + 1 = 'u', end key would be 'v'.
	MinDataKey = []byte{'m'}
	MaxDataKey = []byte{'v'}

	RegionMetaMinKey = []byte{LocalPrefix, RegionMetaPrefix}
	RegionMetaMaxKey = []byte{LocalPrefix, RegionMetaPrefix + 1}

	// Following keys are all local keys, so the first byte must be 0x01.
	prepareBootstrapKey = []byte{LocalPrefix, 0x01}
	storeIdentKey       = []byte{LocalPrefix, 0x02}
)

func RegionRaftPrefixKey(regionID uint64) []byte {
	key := make([]byte, 10)
	key[0] = LocalPrefix
	key[1] = RaftStatePrefix
	binary.BigEndian.PutUint64(key[2:], regionID)
	return key
}

func RaftLogKey(regionID, index uint64) []byte {
	key := make([]byte, 18)
	key[0] = LocalPrefix
	key[1] = RaftLogPrefix
	binary.BigEndian.PutUint64(key[2:], regionID)
	binary.BigEndian.PutUint64(key[10:], index)
	return key
}

func RaftStateKey(region *metapb.Region) []byte {
	key := make([]byte, 18)
	key[0] = LocalPrefix
	key[1] = RaftStatePrefix
	binary.BigEndian.PutUint64(key[2:], region.Id)
	binary.BigEndian.PutUint32(key[10:], uint32(region.RegionEpoch.Version))
	return key
}

func ApplyStateKey(regionID uint64) []byte {
	panic("should not be called")
	// return makeRaftRegionPrefix(regionID, ApplyStateSuffix)
}

func decodeRegionMetaKey(key []byte) (uint64, uint64, uint64, error) {
	if regionMetaKeyLen != len(key) {
		return 0, 0, 0, errors.Errorf("invalid region meta key length for key %v", key)
	}
	if !bytes.HasPrefix(key, RegionMetaMinKey) {
		return 0, 0, 0, errors.Errorf("invalid region meta key prefix for key %v", key)
	}
	regionID := binary.BigEndian.Uint64(key[2:])
	version := binary.BigEndian.Uint32(key[10:])
	confVer := binary.BigEndian.Uint32(key[14:])
	return regionID, uint64(version), uint64(confVer), nil
}

func RegionMetaPrefixKey(regionID uint64) []byte {
	key := make([]byte, 10)
	key[0] = LocalPrefix
	key[1] = RegionMetaPrefix
	binary.BigEndian.PutUint64(key[2:], regionID)
	return key
}

func RegionStateKey(region *metapb.Region) []byte {
	return RegionStateKeyByIDEpoch(region.Id, region.RegionEpoch)
}

func RegionStateKeyByIDEpoch(regionID uint64, epoch *metapb.RegionEpoch) []byte {
	key := make([]byte, 18)
	key[0] = LocalPrefix
	key[1] = RegionMetaPrefix
	binary.BigEndian.PutUint64(key[2:], regionID)
	binary.BigEndian.PutUint32(key[10:], uint32(epoch.Version))
	binary.BigEndian.PutUint32(key[14:], uint32(epoch.ConfVer))
	return key
}

// Get the `start_key` of current region in encoded form.
func RawStartKey(region *metapb.Region) []byte {
	// only initialized region's start_key can be encoded, otherwise there must be bugs
	// somewhere.
	if len(region.StartKey) == 0 {
		// Data starts with 0x01 is used as local key.
		return rawInitialStartKey
	}
	_, decoded, err := codec.DecodeBytes(region.StartKey, nil)
	if err != nil {
		panic(fmt.Sprint(err, region.StartKey))
	}
	return decoded
}

// Get the `end_key` of current region in encoded form.
func RawEndKey(region *metapb.Region) []byte {
	// only initialized region's end_key can be encoded, otherwise there must be bugs
	// somewhere.
	if len(region.EndKey) == 0 {
		return rawInitialEndKey
	}
	_, decoded, err := codec.DecodeBytes(region.EndKey, nil)
	y.Assert(err == nil)
	return decoded
}

/// RaftLogIndex gets the log index from raft log key generated by `raft_log_key`.
func RaftLogIndex(key []byte) (uint64, error) {
	if len(key) != RaftLogLen {
		return 0, errors.Errorf("key %v is not a valid raft log key", key)
	}
	return binary.BigEndian.Uint64(key[RaftLogLen-8:]), nil
}

func IsRaftLogKey(key []byte) bool {
	return len(key) == RaftLogLen && key[0] == LocalPrefix && key[1] == RaftLogPrefix
}

func RaftLogRegionAndIndex(key []byte) (regionID, index uint64) {
	return binary.BigEndian.Uint64(key[RaftLogLen-16:]), binary.BigEndian.Uint64(key[RaftLogLen-8:])
}
